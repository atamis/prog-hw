#lang racket
;; Prog 2 Asg #18: GCD & Mergesort
; Andrew Amis
; Start: 5.8.12
; End: ?
; http://fellowhuman.com/gbk/2012/05/02/prog-2-asg-generative-recursion/

(require test-engine/racket-tests)
(define PROFILE? false)

#|

What is a trivially-solvable instance of the sorting problem?
We have a one element list or an empty list.

What is the solution for a trivial instance?
Return that list.

How are sub-problems generated? How many sub-problems are generated?
Sub-problems are generated by splitting the list into lists of numbers less
than a pivot and greater than a pivot. Those lists are then sorted.

How are the results of solving the sub-problems combined?
Append.

|#

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Exercise 26.1.2 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; make-singles : listof[X] -> listof[sorted-listof[X]]
; Constructs a list of one item lists from a list of items.
(define (make-singles l)
  (map
   {λ (x) `(,x) }
   l))

(check-expect (make-singles (list 2 5 9 3))
              (list (list 2) (list 5) (list 9) (list 3)))
(check-expect (make-singles (list 2 5 9 3 5 5 4 2))
              (list (list 2) (list 5) (list 9) (list 3) (list 5) (list 5)
                    (list 4) (list 2)))

;; recursive-sum : listof[number] -> number
; Recursively sums all the numbers it can find in a list of lists.
(define (recursive-sum list)
  (cond
    [(number? list) list]
    [(empty? list) 0]
    [(cons? list)
     (+ (recursive-sum (car list))
        (recursive-sum (cdr list)))]))
(check-expect (recursive-sum '((((((4)223) 412 ))423) (421 43 5 2))) 1533)


;; merge-lists : listof[X] listof[X] -> listof[X]
; Merges 2 lists together, keeping them in order.
(define merge-lists
  {λ (l1 l2)
    (cond
      [(empty? l1) l2]
      [(empty? l2) l1]
      [(cons? l1)
       (append
        (let ([i1 (car l1)]
              [i2 (car l2)])
          (if (> (recursive-sum i1) (recursive-sum i2))
              (list i2 i1)
              (list i1 i2)))
        (merge-lists (cdr l1) (cdr l2)))])})

(merge-lists '(2 3 4 4) '(1 2 2 4))

(check-expect (merge-lists '(3) '(4)) '(3 4))
(check-expect (merge-lists '(4) '(3)) '(3 4))
(check-expect (merge-lists '(4 6) '(3 5)) '(3 4 5 6))
(check-expect (merge-lists '(4 6) '(3 5 7)) '(3 4 5 6 7))
(check-expect (merge-lists '(3 5 7) '(4 6)) '(3 4 5 6 7))

;; merge-all-neighbors : listof[sorted-listof[X]] -> listof[sorted-listof[X]]
; Merges neighboring lists in the given list.
(define (merge-all-neighbors l)
  (cond
    [(or (empty? l) (empty? (cdr l))) l]
    [(cons? l)
     (cons (let ([first (car l)]
                 [second (cadr l)])  
             (merge-lists first second))
           (merge-all-neighbors (cddr l)))]))

(check-expect (merge-all-neighbors (list (list 2) (list 5) (list 9) (list 3)))
              (list (list 2 5) (list 3 9)))
(check-expect (merge-all-neighbors (list (list 2 5) (list 3 9)))
              (list (list 2 3 5 9)))


;; merge-sort : listof[X] -> sorted-listof[X]
; Sorts the given list.
(define (merge-sort l)
  (letrec ([y {λ (x) (if (= (length x) 1)
                         x
                         (y (merge-all-neighbors x)))}])
    (car (y (make-singles l)))))

(check-expect (merge-sort '(4 2 4 2 1 4 2)) '(1 2 2 2 4 4 4))
(check-expect (merge-sort '(9 7 9 6 9 7 6)) '(6 6 7 7 9 9 9))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Exercise 26.3.1 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; gcd-structural : N[>= 1] N[>= 1]  ->  N
;; to find the greatest common divisior of n and m
;; structural recursion using data definition of N[>= 1] 
(define (gcd-structural n m)
  (local ((define (first-divisior-<= i)
            (cond
              [(= i 1) 1]
              [else (cond
                      [(and (= (remainder n i) 0) 
                            (= (remainder m i) 0))
                       i]
                      [else (first-divisior-<= (- i 1))])])))
    (first-divisior-<= (min m n))))

;; gcd-generative : N[>= 1] N[>=1]  ->  N
;; to find the greatest common divisior of n and m
;; generative recursion: (gcd n m) = (gcd n (remainder m n)) if (<= m n)
(define (gcd-generative n m)
  (local ((define (clever-gcd larger smaller)
            (cond
              [(= smaller 0) larger]
              [else (clever-gcd smaller (remainder larger smaller))])))
    (clever-gcd (max m n) (min m n))))


;; profile : &body -> eval[&body]
; Macro to display the code being run, run the code while timing it, then
; display the result.
(define-syntax-rule (profile x)
  (begin (display (format "Profiling ~s: " 'x))
         (time x)))

(when PROFILE?
  (profile (gcd-structural 101135853 45014640))
  (profile (gcd-generative 101135853 45014640)))


#|
What is a trivially-solvable instance of the GCD problem?
When smaller is 0, when GCD has found the remainder.

What is the solution for a trivial instance?
The remaining remainder, larger.

How are sub-problems generated? How many sub-problems are generated?
One subproblem is generated. They are generated by calling the smaller one the
larger one, and remaindering the larger and the smaller, and calling it the
smaller one.

How are the results of solving the sub-problems combined?
There is only one subproblem, and you combine it with itself with magic.
|#

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Exercise 26.3.3 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

#|

(gcd-generative 101135853 45014640)
(gcd-generative 45014640 11106573)
(gcd-generative 11106573 588348)
(gcd-generative 588348 516309)
(gcd-generative 516309 72039)
(gcd-generative 72039 12036)
(gcd-generative 12036 11859)
(gcd-generative 11859 177)
(gcd-generative 177 0)
177

|#

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Exercise 26.3.4 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

#|

gcd-generative must terminate because each recursive call uses a smaller number
and when it reaches 0, it returns the answer it has calulated.

|#

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Bonus ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; tabulate-divs-dum : number -> listof[number]
; Makes a list of the divisors of the given number, the stupid way.
(define (tabulate-divs-dum n)
  (letrec
      [(internal
        {λ (x)
          (cond
            [(> x (add1 n)) empty]
            [else
             (let [(result (internal (add1 x)))]
               (if (= (remainder n x) 0)
                   (cons x result)
                   result))])})]
    (internal 1))
  
  #;(filter
     {λ (x) (= (remainder n x) 0)}
     (build-list n add1)))

(when PROFILE?
  (profile (car (tabulate-divs-dum 100000))))

(check-expect (tabulate-divs-dum 1) '(1))
(check-expect (tabulate-divs-dum 2) '(1 2))
(check-expect (tabulate-divs-dum 3) '(1 3))
(check-expect (tabulate-divs-dum 12) '(1 2 3 4 6 12))
(check-expect (tabulate-divs-dum 50) '(1 2 5 10 25 50))

;; prime? : number -> boolean
; Checks whether a number is prime using tabulate-divs-dum.
(define (prime-dum? n)
  (let ([divs (tabulate-divs-dum n)])
    (or (equal? divs (list 1 n))
        (equal? divs (list 1)))))

(check-expect (prime-dum? 1) #t)
(check-expect (prime-dum? 2) #t)
(check-expect (prime-dum? 3) #t)
(check-expect (prime-dum? 10) #f)


;; find-first-divisor : number -> number || false
; Finds the first divisor of this number, not including 1. Returns false if its
; prime
(define (find-first-divisor n)
  (letrec ([internal {λ (x)
                    (cond
                      [(= x n) false]
                      [else
                       (if (= (remainder n x) 0)
                           x
                           (internal (add1 x)))])}])
    (internal 2)))
    
(check-expect (find-first-divisor 4) 2)
(check-expect (find-first-divisor 12) 2)
(check-expect (find-first-divisor 9) 3)

;; tabulate-divs : number -> listof[number]
; Returns a list of divisors for the given number
#|(define (tabulate-divs n)
  (letrec ([internal
            {λ (big small)
              (cond
                [(not small) (list big)]
                [else 
                 (let ([divided (/ big small)])
                   (cons divided
                         (internal divided
                                   (find-first-divisor divided))))])}])
    (cond
      [(= n 1) '(1)]
      [else
       (internal n (find-first-divisor n))])))
  
(tabulate-divs 12)
(check-expect (tabulate-divs 1) '(1))
(check-expect (tabulate-divs 2) '(1 2))
(check-expect (tabulate-divs 3) '(1 3))
(check-expect (tabulate-divs 12) '(1 2 3 4 6 12))
(check-expect (tabulate-divs 50) '(1 2 5 10 25 50))

|#

(test)